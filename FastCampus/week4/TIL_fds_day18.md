# 4/11(수)

## 1. Today I learned

### 1-1. 함수

#### 함수

- 함수란 프로그래밍에 있어, 큰 프로그램을 잘게 쪼개어 특정 코드 뭉치를 반복해서 사용 할 수 있도록 묶어놓은 코드 뭉치의 단위를 말한다. 함수를 어떻게 작성함에 따라 코드의 **유지보수**성과 **가독성**이 크게 달라진다.

#### 함수의 구성 요소

- 기본적으로 함수의 구성요소는 이와 같다.

  ```js
  function add(x,y){
    const result = x + y;
    return result;
  }
  ```

  - 가장 기본적인 구성 요소이며 `add`는 함수의 이름을 정의, 괄호 안의 `x`와 `y`는 매개변수(parameter)라 하며, `return`뒤에 오는 값을 반환값(return value)라 한다.

- 이와같이 정의한 함수를 사용 할 때에는 함수이름뒤에 괄호를 붙혀서 함수를 호출할수 있다.

  ```js
  add(2,3); // 5
  ```

  - 이 때 괄호안의 넘겨준 `2`,`3`은 인수(argument)라고 부른다.

#### 스코프 (Scope)

- 함수의 매개변수를 비롯한, 모든 변수들은 특별한 성질을 갖고있다.

  ```js
  function add(x, y) { // 변수 `x`와 `y`가 정의됨
  return x + y;
  }
  add(2, 3);
  console.log(x); // 에러!
  ```

  - 위처럼 매개변수와 같이 함수 안에서(`add(x,y)`) 정의된 변수는 함수바깥에서 접근할 수가 없다. 즉 함수 안에서만 사용할수 있다는 것이다. 변수는 코드의 일정 범위 안에서만 유효하다는 성질이 있으며, 이렇게 특정 변수가 유효한 코드 상의 유효 범위를 가지고 **스코프(scope)**라 한다.

#### 익명 함수

- JavaScript에서 함수를 선언할 때 꼭 이름을 붙여주어야 하는 것은 아니다. 아래와 같이 이름을 붙이지 않은 함수를 가지고 익명 함수, 혹은 함수 리터럴이라고 한다.

  ```js
  // 두 수를 더해서 반환하는 익명 함수
  function(x, y) {
    return x + y;
  }
  // 위의 익명 함수는 이름이 없어서 이름을 가지고 호출을 할 수 없습니다.

  // 호출을 하려면 변수에 저장한 후에 변수의 이름을 통해 호출해야 합니다.
  const add = function(x, y) {
    return x + y;
  }
  add(1, 2); // 3
  ```

  - 익명 함수는 함수를 만든 쪽이 아니라 다른 쪽에서 그 함수를 호출할때 많이 사용된다. 대표적인 경우는 함수를 인수를 넘겨줄 때이다. 

#### 화살표 함수

- 화살표 함수는 함수를 정의하기위한 새로운 표기법이며 ES2015에서 도입되었다.

  ```js
  // 여기에서 x + y 는 **바로 반환됩니다.**
  const add = (x, y) => x + y;

  // 바로 반환시키지 않고 function 키워드를 통한 함수 정의처럼 여러 구문을 사용하려면 curly braces({...}) 로 둘러싸주어야 합니다.
  // `=>` 다음 부분을 중괄호로 둘러싸면, 명시적으로 `return` 하지 않는 한 아무것도 반환되지 않습니다.
  const add = (x, y) => {
    const result = x + y;
    return result;
  }
  // 매개변수가 하나밖에 없다면, 매개변수 부분의 괄호를 쓰지 않아도 무방합니다.
  const negate = x => !x;
  ```

  - 화살표 함수는 표기법이 간단하기 떄문에 익명 함수를 다른 함수의 인수로 넘길 때 주로 사용된다.
    
    ```js
    [1, 2, 3, 4, 5].filter(x => x % 2 === 0);
    ```

### 1-2. 제어 구문

#### 배열의 순회

- ES2015가 나오기 이전까지는 `for` 구문이 배열을 순회하는 데에도 많이 사용되었다.

  ```js
  const arr = [1, 2, 3, 4, 5];

  for (let i = 0; i < arr.length; i++) {
    console.log(`배열의 ${i + 1} 번째 요소는 ${arr[i]} 입니다.`);
  }
  ```

  - 하지만 근래에는 배열의 `foreach`메소드나 `for...of`구문이 더 많이 쓰이는 편이다.

  ```js
  alert('퀴즈를 시작합니다.');
  while (true) {
    const answer = prompt('빨강의 보색은 무엇일까요?');
    if (answer === '초록') {
      alert('정답입니다! 🎉');
      break; // 루프를 종료하고 다음 코드로 넘어감
    } else {
      alert('틀렸습니다! 다시 시도해보세요.');
    }
  }
  alert('퀴즈가 끝났습니다.');

  ///////////////////////////////////////

  for (let i = 1; i < 100; i++) {
    console.log(`현재 숫자는 ${i} 입니다.`);
    if (i % 7 !== 0) {
      continue; // 루프의 나머지 코드를 건너뜀
    }
    console.log(`${i}는 7의 배수입니다.`);
  }
  ```

#### 함수를 즉시 종료하기

- `throw`
  
  ```js
  function translateColor(english) {
    switch (english) {
      case 'red': return '빨강색';
      case 'blue': return '파랑색';
      case 'purple':
      case 'violet': return '보라색';
      default: throw new Error('일치하는 색깔이 없습니다.');
    }
  }
  ```

  - `throw` 구문은 코드의 실행을 중단시키고 에러를 발생시키는 동작을 합니다.

## 2. Today I found out
  - 여러가지 기본적이고 간단한 알고리즘 문제들을 풀어보면서 느낀거지만 거의 백지 상태나 다름없단 생각이 들었다. 알 것 같으면서도 자꾸 버벅이게 되었고, 제어,반복문들의 돌아가는 로직은 어느정도 이해되지만 순간순간 어떤 메소드를 사용해야 적절할지에 대해서는 아직 학습이 많이 부족한거 같다.
  더더더더 열심히 해야 될 것 같다.....  
## 3. Ref