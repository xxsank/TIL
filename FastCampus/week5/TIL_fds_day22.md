# 4/17(화)

## 1. Today I learned

### 1-1. 값 더 알아보기

#### let, const 변수와 블록 스코프

- 먼저 `let`과 `const` 변수는 재선언을 허용하지 않는다.
- ES2015 이전에는 재선언을 하면서 써도 에러가 나지 않았지만, 결국 가독성이나 유지보수를 어렵게 만드는 결과로 ES2015에 들어와서는 그 제약이 강화 되었다.
- `let`과 `const`는 블록 스코프를 갖는다 (스코프는 유효 범위)

#### var 변수 ,함수 스코프

- `var`를 통해 선언된 변수는 재선언을 **허용**한다.
- `var`로 선언된 변수는 내부적으로 함수 혹은 파일의 맨 위로 끌어 올려지는 과정 떄문에 같은 스코프 안에만 있다면 변수가 선언되기 전에도 해당 변수에 접근할 수 있다. 이러한 현상을 `호이스팅(hositing)`이라 한다.
  - 면접때 종종 나올수 있으니 외워두도록 하자.

\ | const | let | var
 ------|------|------|-----
 스코프|  블록 스코프 | 블록 스코프 | 함수 스코프
 재대입 | X | O | O
 재선언 | X | X | O
 호이스팅 | X | X | O
 사용권장 | 1순위 | 2순위 | 3순위

#### 전역 변수 (Globla Variable)

- 전역 스코프는 스코프 체인의 가장 바깥쪽에 있는 스코프.

  ```js 
  let foo;   // `foo`는 전역 스코프에서 선언

  if(true){
    let bar; // `bar`는 블록 스코프에서 선언
  }
  ```

  - 위 예제와 같이 `foo`같이 전역 스코프에서 선언된 변수를 전역 변수라 한다.

- 전역 변수의 코드는 아무런 제한없이 접근하고 조작이 가능하다.
- 전역 변수를 써야 하는 상황에서 경각심을 갖고 사용해야 한다. (프로그램의 너무 많은 부분이 **결합**되거나 코드가 전혀 다른 곳에 위치한 부분에 의존하게 되므로, 전역 변수를 사용한 코드는 이해하기 어렵다. )
- 전역변수를 선언하면 전역객체의 속성이된다.

#### 전역 객체 

- JavaScript 구동 환경은 모두 **전역 객체** 라는 특별한 객체를 갖고 있으며, 전역 변수가 선언되면, 이 변수 또한 **전역 객체의 속성** 이 되어 전역 객체를 통해서도 접근이 가능하다.

  구동환경 | 전역 객체 이름
  --------|---------
  웹 브라우저 | `window`
  웹 워커 | `self`
  Node.js | `global`

- 전역 객체는 구동 환경에서 유용하게 쓸 수 있는 속성과 함수가 미리 적재되어있다.

#### 참조(Reference)

- JavaScriptd의 일곱 가지 타입
  - Boolean
  - Null
  - Undefined
  - Number
  - String
  - Symbol
  - Object

- 위 타입중 `Object`의 타입, 즉 객체를 제외하고는 모두 원시 타입이다. 객체는 참조 타입으로 불르며, 참조란 객체가 컴퓨터 메모리 상에서 어디에 저장 되있는지 가르키는 값.

- 객체의 속성에 접근하면, JavaScript 엔진은 **참조를 통해 메모리에 저장 되어있는 객체에 접근해 해당 객체의 속성을 읽는다.** 이런동작을 역참조라함.

#### 객체의 같음(Equality)

  ```js
  {prop : 1} === {prop: 1}; // false
  [1,2,3] === [1,2,3]; // false
  ```

  - 위 등호 연산자는 객체의 내용을 비교하는것이 아니라 객체의 `참조`를 비교 하는 것이다. 내용이 똑같아 보일지라도 각각 다른 메모리 위치의 저장되므로 그에대한 참조는 서로 다른것이다.

#### 불변성

- 원시 타입의 값 자체의 내용을 변경할수 있는 방법은 `없다.` 이런 성질을 `불변성`이라 하며 "자바 스크립트의 원시 값은 불변이다" 라고 말한다.

- 기존 문자열의 내용을 바꾸는 메소드는 전부없다, 새 문자열을 반환하는 메소드이며, 다른 원시 타입의 메소드들도 마찬가지이다.

- 변수에 저장된 원시 타입의 값을 바꾸려면, 변수에 다른 값을 대입하는 방법밖에 없음.

#### 래퍼 객체(Wrapper Object)

- 원시 타입에 점(.) 표기법을 써서 메소드를 호출하거나 속성을 읽어 올 수 있는데. 이는 JavaScript가 래퍼 객체라는 기능을 제공 하기 때문이다.

- 원시 타입의 값에 속성을 읽으려고 시도하면, 그 값은 그 순간에만 객체로 변환되어 **마치 객체인 것처럼 동작합니다.**

## 2. Today I found out
- 기존의 문자열 메소드를 사용할때 내용을 바꾸는 줄 알았지만 사실은 기존의 문자열의 내용을 바꾸는 메소드는 절대 없다는것을 알게 되었다. 문자열의 내용을 바꾸는것이 아닌 새 문자열을 반환하는 메소드이며 문자열과 다르게 배열의 메소드들은 안의 내용을 직접적으로 수정할 수 있다는것을 알게되었다.

- 옛날에 다른 언어들을 조금씩 배워논것들이 겹쳐지게 생각하는 습관을 버려야 할 것 같다. 새로운 언어를 배우는만큼 그 언어에 익숙해져야 하는데, 다른데선 됐는데 왜 JS에선 안되지라는 생각을 멀리하고 항상 새롭게 배우는느낌으로 JS에 익숙해지도록 열심히 공부해야겠다.
  
## 3. Ref

[웹사이트 배포 서비스 Netlify](https://www.netlify.com/)