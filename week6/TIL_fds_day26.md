# 4/23(월)

## 1. Today I learned

### 1-1. 연산자 더 알아보기

#### 표현식
- 코드 중에 값으로 변환될 수 있는 부분을 표현식 이라고 한다.
  - 리터럴
  - 연산자
    - `delete obj.prop`
    - `typeof null`
    - `'prop' in obj`
    - `obj instanceof Object`
    - `new Object()`
    - `variable = 1`
  - 기타
    - `this`
    - `variable`
    - `obj.prop`
    - `func()`
- 표현식을 값으로 변환하기 위해 실제로 해당 표현식을 실행시키는 절차를 **평가(evaluation)**라고 한다. 
- 연산자에 따라 평가하는 순서가 달라진다.

#### Short-circuit Evaluation(단축평가)
- 피연산자가 두 개인 연산 중에, 값을 결정하기 위해 양쪽 피연산자가 모두 필요하지 않은 경우가 있다. 아래와 같은 평가 방식을 단축 평가라고 한다.
  ```js
  false && expression
  true || expression
  ```
  - `&&` - 왼쪽 피연산자를 평가해 **falsy** 이면 이 값을 바로 반환한다. 아니라면 오른족 피연산자를 평가한 결과값 반환.
  - `||` - 왼쪽 피연산자를 평가해 **truthy** 이면 이 값을 바로 반환한다. 아니라면 오른족 피연산자를 평가한 결과값 반환.
- 위 성질들을 이용해 `if` 구문을 흉내내는것도 가능하다.
- `||` 연산자는 기본 매개변수 문법이 생기기 전까지 매개변수의 기본값을 지정하는 용도로 많이 사용하였다.
- 코드가 짧아진다고 좋은코드가 아니라 눈에 잘 읽히는게 좋은 코드!

#### 삼항 연산자
- `a ? b : c` - `a`가 truthy 이면 `b`가, falsy 이면 `c`가 반환.
- 삼항연산자 역시 필요가 없는 부분은 평가하지 않는다.

#### 증가/감소 연산자
- 자바스크립트에는 1 단위로 정수의 증가/감소 연산을 할 수 있는 `++`, `--`연산자가 있다.
  - `++` 연산자는 피연산자의 값을 1 증가 시킨다. 단,
    - `++` 연산자를 피연산자 **앞**에 쓰면, 그 표현식은 값을 증가시키고 뒤의 결과값을 반환한다.
    - `++` 연산자를 피연산자 **뒤**에 쓰면, 그 표현식은 **값을 증가시키기 전의 피연산자를 그대로 반환한다**.
  - `--` 연산자도 위처럼 동작한다.

#### 할당 연산자
- `=` 연산자를 비롯해, 연산 후 할당을 하는 `+=`,`-=`등등의 연산자 모두 피연산자와 함께 포현식을 이룬다.
  ```js
  let x;
  console.log(x = 5); // 5
  console.log(x += 5); // 10
  
  let y = 6;
  console.log(y -= 3); //3
  ```
  - 할당 연산자에 대한 표현식의 결과값은 `왼쪽 피연산자에 실제로 할당된 값` 이된다.

#### 연산자 결합 순서
  ```js
  // 위아래 식은 완전히 같은 방식으로 동작합니다.
  1 + 2 + 3 + 4 + 5
  (((1 + 2) + 3) + 4) + 5

  // 왼쪽부터 결합되어, 처음으로 등장하는 falsy 값이 표현식의 결과값이 됩니다. 나머지는 평가되지 않습니다.
  a && b && c && d;
  ((a && b) && c) && d;

  // 왼쪽부터 결합되어, 처음으로 등장하는 truthy 값이 표현식의 결과값이 됩니다. 나머지는 평가되지 않습니다.
  a || b || c || d;
  ((a || b) || c) || d;
  ```
- 연산자의 결합성 때문에, 수학에서 쓰이는 식을 JavaScript에서는 그대로 쓸 수 없다.
  ```js
  // 위아래 식은 완전히 같은 방식으로 동작합니다.
  // 결과적으로 `true > 1`이 되어 결과값이 `false`가 됩니다.
  3 > 2 > 1;
  (3 > 2) > 1;
  true > 1; // false

  // 세 개의 수에 대한 비교를 하고 싶다면 아래와 같이 해야 합니다.
  3 > 2 && 2 > 1; // true

  2 ** 2 ** 3; // 256
  2 ** (2 ** 3); // 256

  // 위아래 식은 완전히 같은 방식으로 동작합니다.
  let x, y, z;
  z = y = x = 1
  z = (y = (x = 1))

  // 위아래 식은 완전히 같은 방식으로 동작합니다.
  a ? b : c ? d : e ? f : g
  a ? b : (c ? d : (e ? f : g))
  ```
- **거듭제곱 연산자**, **할당 연산자**, **삼항 연산자** 는 우결합성을 가진다.
- 삼항연산자는 if ~ else 처럼 여러개로 쓸 수 있다.(가독성이 좀 더 떨어지므로 if ~ else를 쓰는것을 권장한다. 삼항연산자를 쓸 때도 물론 있다.)

#### 값을 비교하는 여러 가지 방법
- JavaScript 에서는 두 값이 같은지 비교하기 위한 세 가지 방법을 사용할 수 있다.
  - `==`,`!=`
  - `===`,`!=`
  - `Object.is`

- `NaN === NaN` 유일하게 false가 나온다. `number.isNaN(num)` 메소드를 이용해 사용해주어야 한다.
- `0 === -0` 은 같은 것으로 취급된다. (실제론 별개의 값)ㅔ
- **`Object.is`**
  - 두 인수가 **정말로 같은 값 인지**를 검사한다.  
- 특별한 경우를 제외하고는 `===` 혹은 `!==` 연산자를 사용해서 비교, 다만 null check를 할 때만큼은 `==` 혹은 `!=` 연산자를 사용하는 것이 편함

#### Spread Syntax
- Spread 문법을 사용하면 배열(혹은 객체)를 다른 배열(혹은 객체)에 쉽게 삽입 할 수 있다. 
  ```js
  // 배열안의 요소가 삽입되는 것, ...을 붙히지 않으면 그냥 배열자체를 삽입
  const arr1 = [3, 4];
  const arr2 = [1, 2, ...arr1, 5]; // [1, 2, 3, 4, 5]

  // 이전에는 같은 작업을 하기 위해 `Array.prototype.concat` 메소드를 사용했습니다.
  [1, 2].concat(arr1).concat([5]) // [1, 2, 3, 4, 5]
  ```
  - 다만 깊은복사가아니라 **얕은 복사** 이다. 깊은복사를 하고싶을때는 라이브러리를 이용해야 한다.
    ```js
    // 이런방식으로도 깊은복사를 할 수 있다.

    const arr1 = [1, 2, 3, [4, 5]];
    const arr2 = [
      ...arr1.slice(0, 3),
      [...arr1[3]]
    ];

    arr2[3][0] = 40;
    console.log(arr1[3][0]);
    ```
  - 배열안의 배열을 복사할때는 참조이다.
- 객체에 대해서도 spread 문법을 사용할 수 있다.

#### 분해대입
- 배열의 분해대입
  - 변수의 선언과 동시에 배열의 요소를 해당 변수에 대입할 수 있다.
    ```js
    const [a,b,c] = [1,2,3];
    console.log(a,b,c); // 1 2 3
    ```
    - 만약 요소의 순서와 일치하는 변수가 좌측 목록에 없으면 ,해당 요소는 무시됨.

    ```js
    const [a, ,c] = [1,2,3,4];
    console.log(a, c); //1 3
    ```

- 객체의 분해대입
  - 속성값만 대입할 수 있다.  
   
    ```js 
    /* 보통 많이 쓰이는 표현 */
    const {a, b} = {a: 1, b: 2};
    console.log(a, b); // 1 2
    ```

  - 이미 선언된 변수에도 분해대입을 할 수 있다.
  - 객체가 중첩되어 있으면, 해당 객체에 대해서도 분해대입을 할 수 있으며 등호 좌측에서도 객체가 중첩된 것처럼 작성해야 한다.
- 매개변수에서의 분해대입
  - 함수의 매개변수에서도 분해대입을 할 수 있다.

    ```js
    function func({prop, array: [item1, item2, item3 = 4]}){
      console.log(prop);
      console.log(item1);
      console.log(item2);
      console.log(item3);
    }
    /* 1, 2, 3, 4가 차례대로 출력됩니다.*/
    func({prop: 1, array: [2, 3]});
    ```

## 2. Today I found out
- 증감연산자의 동작 원리에대해 좀 더 자세히 알 수 있었고, 평가라는 낯선개념이 있었지만 이러한 원리때문에 연산자들이 어떻게 돌아가는지에 대해 좀 더 자세히 알 수 있었다.
  
## 3. Ref
[추상 구문 트리](https://ko.wikipedia.org/wiki/%EC%B6%94%EC%83%81_%EA%B5%AC%EB%AC%B8_%ED%8A%B8%EB%A6%AC)  
[연산자 우선순위](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Operators/%EC%97%B0%EC%82%B0%EC%9E%90_%EC%9A%B0%EC%84%A0%EC%88%9C%EC%9C%84)  
[Web API](https://developer.mozilla.org/en-US/docs/Web/API)