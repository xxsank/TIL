# 5/21(월)

## 1. Today I learned

### 1-1. CORS

#### Same-origin Policy (동일 출처 정책)
- 웹페이지에서 리소스를 불러올 때, 리소스의 출처가 웹페이지의 출처와 같으면 안전, 출처가 다르면 해당 리소소는 안전하지 않다고 보는 원칙.
- 출처란 '프로토콜 + 도메인 + 포트번호'의 결합을 가리킴. 즉 **세 개가 다 같아야 동일 출처** 라고 할 수 있다. 셋 중에 하나라도 다르면 동일 출처로 간주되지 않음.
- **웹 보안의 기본 원칙**, 웹 브라우저의 많은 요소에 적용됨.
- http, https는 서로 다른 출처이다.
  ```js
  > const child = window.open('http://www.fastcampus.co.kr')
  // 새로 열린 웹 페이지의 콘솔에서
  > window.foo = 'bar'
  // 이전 웹 페이지의 콘솔에서
  > child.foo
  // 출처가 같다면 접근 가능, 아니면 불가
  ```
  - 동일 출처면 전역객체에 접근이 가능하다.

#### Content-Security-Policy
- 이 헤더를 이용하면, **동일하지 않은 출처에 대한 리소스를 불러올지 말지** 결정할 수 있다.
- 안전하게 리소스를 제공.
- 응답에 포함시켜야 하는 헤더이다.
- 보통 서버개발자가 사용하는 기법.

#### CORS(Cross-Origin Resource Sharing)
- 클라이언트 측 cross-origin 요청을 안전하게 보낼 수 있는 방법을 정한 표준
- 쉽게 말하면, 스크립트가 전혀 다른 출처를 갖는 API서버를 사용하려고 하는 상황에서 뭔가 추가적인 처리를 해주어야 한다는 것.

#### CORS - Safe, Unsafe
- 요청,응답을 한번씩은 받아봐야 Cross-Origin이 허용하는지 알 수가 있다.
- POST, PUT, PATCH, DELETE로 ajax 요청을 보낼때는 한번을 보냈어도 두번들어갈 수 있기 때문에 위험하다. 요청이 한번 더 갈수 있다.

#### CORS with credentials
- cross-origin 요청에는 기본적으로 쿠키가 포함되지 않으나, XMLHttpRequest 혹은 fetch를 통해서 요청을 보낼 때 쿠키를 포함시키는 옵션을 줄 수 있고 이 때 CORS 요건이 더 엄격해짐

### 1-2 JWT
- Access Token & JWT

#### 쿠키의 단점
- 쿠키를 지원하는 클라이언트에서밖에 사용할 수 없음
- 적절히 관리되지 않은 쿠키는 보안에 취약하며, 관리를 하려고 해도 CORS 대응이 복잡함

#### 토큰 사용의 장점
- 다양한 인증수단(내가 누구인지를 밝히기 위해서 쓰이는 정보를 말함)의 인증결과를 **토큰이라는 하나의 수단으로 통일**할 수 있음.
- 쿠키를 지원하지 않는 클라이언트에서도 편하게 사용할 수 있음.
- 쿠키를 사용하지 않음으로써 **CORS 관련 문제를 회피**할 수 있음.

#### 토큰 사용의 단점
- 매 요청에 토큰이 포함되게 되므로 적당히 짧은 길이를 유지해야 함
- 토큰 유출에 대한 대비책이 필요 (토큰에 유효기간을 두거나, 유출된 토큰을 강제로 무효화하는 등의 방법을 사용)
- 쿠키와는 다르게, 클라이언트 개발자가 직접 토큰을 저장하고 관리해야 함

#### Web Storage
- 브라우저에서 키-값 쌍을 저장할 수 있는 저장소
- 쿠키에 비해 사용하기 편리하고 저장 가능한 용량도 큼(10MB 가량)
- 브라우저 탭이 닫히면 내용이 삭제되는 **sessionStorage**, 브라우저 탭이 닫혀도 내용이 유지되는 **localStrage**가 있음.

#### 보안상 주의사항
- (당연히) HTTPS를 사용해야 함
- 토큰을 localStorage에 저장하게 되면 자바스크립트로 토큰을 탈취할 수 있게 되므로, **웹사이트에 악성 스크립트를 삽입하는 공격(XSS)**에 노출되지 않도록 신경써야 함

#### JSON Web Token
- 최근 널리 사용되고 있는 토큰 형식의 표준
- 토큰 안에 JSON 형식으로 정보를 저장함
- 보안을 위해 서명 또는 암호화를 사용할 수 있음
- 정보가 포함되있다는게 제일 중요하다.


### 1-3  Fetch API

#### Fetch API
- 웹 브라우저의 XMLHttpRequest를 대체하기 위해 만들어진 새로운 HTTP client 표준
- 비교적 최근에 도입되어 IE 및 구형 안드로이드 브라우저(4.x)는 지원하지 않음
- Node.js에서 쓸수있는 Fetch - [isomorphic-fetch](https://www.npmjs.com/package/isomorphic-fetch)

#### Axios vs Fetch API
- Axios는 여러 편의기능(instance와 같이 설정을 재사용하거나 요청중인 연결을 취소하는 등)을 제공
- 다만, Axios는 내부적으로 XMLHttpRequest를 사용하고 있는데 Service Worker 등의 최신 기술이 XMLHttpRequest를 지원하지 않으므로, Service Worker를 사용할 예정에 있는 프로젝트에서는 Axios 대신 Fetch API를 사용해야만 함

### 1-4 HTTP Cache

#### Cache
- 데이터 분야에서의 캐시는(주로 접근 속도의 개선을 위해) 데이터를 미리 복사해 놓는 임시 저장소, 혹은 그 임시 저장소에 데이터를 저장하는 행위를 가리킴
- cache' 혹은 'caching'이라는 용어 자체는 특정 기술을 가리키는 것이 아니라, 접근 속도를 개선하기 위해 따로 저장소를 두는 '방법'을 가리킴
- [컴퓨터의 아주 많은 부분(CPU, GPU, HDD, 네트워크, 웹, 데이터베이스...)에서 사용되고 있음

#### HTTP Cache
- 자원의 효율적 로딩을 위한 웹 표준
- 서버에서 가져온 자원(HTML, CSS, JS, 이미지, ...)을 가까운 곳(브라우저, 혹은 다른 서버)에 저장해놓고 재사용
- 캐시를 할 것인지 말 것인지, 어떻게 할 것인지를 결정하는 규칙이 복잡하고, 브라우저마다 조금씩 다름

### 1-5 GraphQL

#### REST API의 단점
- 각각의 자원마다 경로가 따로 있음. 즉, 여러 자원이 동시에 필요한 경우에는 **요청을 여러 번 보내야 함** (요청의 횟수 면에서 비효율적)
- (보통의 경우) 자원의 필요한 속성만 얻어올 수 없음. 즉, **일부 속성의 필요하더라도 전체 속성을 가져와야만 함** (요청의 용량 면에서 비효율적)

#### GraphQL
- Facebook에서 2015년 공개한 **데이터 질의 언어**
- REST API를 대체하기 위해 만들어짐
- 클라이언트에서 필요한 **데이터의 구조**를 GraphQL 언어로 정의한 후 질의할 수 있고, 서버는 그에 맞게 구조화된 데이터를 응답
- 서버에서는 GraphQL 질의를 해석하기 위해 별도의 해석기가 필요하며, 여러 언어의 구현체가 나와있는 상태